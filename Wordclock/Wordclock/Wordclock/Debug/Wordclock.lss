
Wordclock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000c22  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000bae  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000017a  00800100  00800100  00000c22  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000c22  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000c54  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003c0  00000000  00000000  00000c94  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c8de  00000000  00000000  00001054  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001f77  00000000  00000000  0000d932  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000345b  00000000  00000000  0000f8a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d10  00000000  00000000  00012d04  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000f006  00000000  00000000  00013a14  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000598f  00000000  00000000  00022a1a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000438  00000000  00000000  000283a9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00009025  00000000  00000000  000287e1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 0d 01 	jmp	0x21a	; 0x21a <__dtors_end>
   4:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
   8:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
   c:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  10:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  14:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  18:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  1c:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  20:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  24:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  28:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  2c:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  30:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  34:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  38:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  3c:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  40:	0c 94 c9 04 	jmp	0x992	; 0x992 <__vector_16>
  44:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  48:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  4c:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  50:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  54:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  58:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  5c:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  60:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>
  64:	0c 94 2a 01 	jmp	0x254	; 0x254 <__bad_interrupt>

00000068 <_ZN5Clock12MinutesTableE>:
  68:	00 00 00 00 00 01 00 03 0a 00 01 00 04 0a 00 01     ................
  78:	00 08 0a 00 01 01 04 0b 0c 01 01 03 0b 0c 01 01     ................
  88:	0c 00 00 01 01 03 0a 0c 01 01 04 0a 0c 01 01 08     ................
  98:	0b 00 01 01 04 0b 00 01 01 03 0b 00 00 00 00 00     ................
  a8:	00 01 00 03 0a 00 01 00 04 0a 00 01 01 08 00 00     ................
  b8:	01 01 04 0b 0c 01 01 03 0b 0c 01 01 0c 00 00 01     ................
  c8:	01 03 0a 0c 01 01 04 0a 0c 01 01 09 00 00 01 01     ................
  d8:	04 0b 00 01 01 03 0b 00 00 00 00 00 00 01 00 03     ................
  e8:	0a 00 01 00 04 0a 00 01 00 08 0a 00 01 00 05 0a     ................
  f8:	00 01 01 03 0b 0c 01 01 0c 00 00 01 01 03 0a 0c     ................
 108:	01 01 05 0b 00 01 01 08 0b 00 01 01 04 0b 00 01     ................
 118:	01 03 0b 00 00 00 00 00 00 01 00 03 0a 00 01 00     ................
 128:	04 0a 00 01 01 08 00 00 01 00 05 0a 00 01 01 03     ................
 138:	0b 0c 01 01 0c 00 00 01 01 03 0a 0c 01 01 05 0b     ................
 148:	00 01 01 09 00 00 01 01 04 0b 00 01 01 03 0b 00     ................

00000158 <_ZN5Clock10HoursTableE>:
 158:	0d 1a 0f 1a 0e 1a 12 1a 16 1a 13 1a 19 1a 11 1a     ................
 168:	17 1a 15 1a 18 1a 14 1a 0d 00 10 00 0e 00 12 00     ................
 178:	16 00 13 00 19 00 11 00 17 00 15 00 18 00 14 00     ................

00000188 <_ZN7Display21WordIlluminationTableE>:
 188:	00 00 00 00 00 02 00 03 03 00 07 04 01 00 04 01     ................
 198:	04 07 02 00 04 02 04 04 02 04 07 02 00 0b 03 02     ................
 1a8:	04 03 06 03 04 00 04 04 05 05 05 00 04 05 02 03     ................
 1b8:	05 02 04 05 05 06 06 01 04 06 07 04 07 00 03 07     ................
 1c8:	03 04 07 07 04 08 01 04 08 05 04 09 01 05 09 08     ................
 1d8:	03                                                  .

000001d9 <digital_pin_to_bit_mask_PGM>:
 1d9:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
 1e9:	04 08 10 20                                         ... 

000001ed <digital_pin_to_port_PGM>:
 1ed:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
 1fd:	03 03 03 03                                         ....

00000201 <port_to_output_PGM>:
 201:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

0000020b <port_to_mode_PGM>:
 20b:	00 00 00 00 24 00 27 00 2a 00 00                    ....$.'.*..

00000216 <__ctors_start>:
 216:	42 01       	movw	r8, r4

00000218 <__ctors_end>:
 218:	58 01       	movw	r10, r16

0000021a <__dtors_end>:
 21a:	11 24       	eor	r1, r1
 21c:	1f be       	out	0x3f, r1	; 63
 21e:	cf ef       	ldi	r28, 0xFF	; 255
 220:	d8 e0       	ldi	r29, 0x08	; 8
 222:	de bf       	out	0x3e, r29	; 62
 224:	cd bf       	out	0x3d, r28	; 61

00000226 <__do_clear_bss>:
 226:	22 e0       	ldi	r18, 0x02	; 2
 228:	a0 e0       	ldi	r26, 0x00	; 0
 22a:	b1 e0       	ldi	r27, 0x01	; 1
 22c:	01 c0       	rjmp	.+2      	; 0x230 <.do_clear_bss_start>

0000022e <.do_clear_bss_loop>:
 22e:	1d 92       	st	X+, r1

00000230 <.do_clear_bss_start>:
 230:	aa 37       	cpi	r26, 0x7A	; 122
 232:	b2 07       	cpc	r27, r18
 234:	e1 f7       	brne	.-8      	; 0x22e <.do_clear_bss_loop>

00000236 <__do_global_ctors>:
 236:	11 e0       	ldi	r17, 0x01	; 1
 238:	cc e0       	ldi	r28, 0x0C	; 12
 23a:	d1 e0       	ldi	r29, 0x01	; 1
 23c:	04 c0       	rjmp	.+8      	; 0x246 <__do_global_ctors+0x10>
 23e:	21 97       	sbiw	r28, 0x01	; 1
 240:	fe 01       	movw	r30, r28
 242:	0e 94 bb 05 	call	0xb76	; 0xb76 <__tablejump2__>
 246:	cb 30       	cpi	r28, 0x0B	; 11
 248:	d1 07       	cpc	r29, r17
 24a:	c9 f7       	brne	.-14     	; 0x23e <__do_global_ctors+0x8>
 24c:	0e 94 ba 04 	call	0x974	; 0x974 <main>
 250:	0c 94 ca 05 	jmp	0xb94	; 0xb94 <__do_global_dtors>

00000254 <__bad_interrupt>:
 254:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000258 <setup>:
  //} else {
//		flag = 0;
  //}
  //wcAnimation.setChar(0,0, 'T', ANIMATION_FONT_4X6);
  
  wcAnimation.setAnimation(Animation::ANIMATION_TELETYPE);
 258:	60 e0       	ldi	r22, 0x00	; 0
 25a:	80 e0       	ldi	r24, 0x00	; 0
 25c:	91 e0       	ldi	r25, 0x01	; 1
 25e:	0e 94 94 01 	call	0x328	; 0x328 <_ZN9Animation12setAnimationENS_13AnimationTypeE>
  wcAnimation.setClock(12, 10);
 262:	4a e0       	ldi	r20, 0x0A	; 10
 264:	6c e0       	ldi	r22, 0x0C	; 12
 266:	80 e0       	ldi	r24, 0x00	; 0
 268:	91 e0       	ldi	r25, 0x01	; 1
 26a:	0c 94 a0 01 	jmp	0x340	; 0x340 <_ZN9Animation8setClockEhh>

0000026e <loop>:
void loop() {
  // put your main code here, to run repeatedly:
  //wcClock.setClock(17,30);
  //wcDisplay.show();
  //wcDisplay.clearAllWords();
  wcAnimation.task();
 26e:	80 e0       	ldi	r24, 0x00	; 0
 270:	91 e0       	ldi	r25, 0x01	; 1
 272:	0e 94 a9 01 	call	0x352	; 0x352 <_ZN9Animation4taskEv>
    void setPixelRowFast(byte, PixelRowType);
    void setPixelColumnFast(byte, PixelColumnType);

    // methods
    void init();
    void show() { Pixels.show(); }
 276:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 27a:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <_edata+0x1>
 27e:	01 96       	adiw	r24, 0x01	; 1
 280:	0c 94 90 04 	jmp	0x920	; 0x920 <_ZN6WS28124showEv>

00000284 <_GLOBAL__sub_I_flag>:
#include "Display.h"
#include "Animation.h"
#include "Clock.h"
/*End of auto generated code by Atmel studio */
int flag;
Display wcDisplay(20, 20, 20);
 284:	24 e1       	ldi	r18, 0x14	; 20
 286:	44 e1       	ldi	r20, 0x14	; 20
 288:	64 e1       	ldi	r22, 0x14	; 20
 28a:	88 e1       	ldi	r24, 0x18	; 24
 28c:	91 e0       	ldi	r25, 0x01	; 1
 28e:	0e 94 1d 03 	call	0x63a	; 0x63a <_ZN7DisplayC1Ehhh>
Clock wcClock(&wcDisplay, Clock::MODE_WESSI);
 292:	40 e0       	ldi	r20, 0x00	; 0
 294:	68 e1       	ldi	r22, 0x18	; 24
 296:	71 e0       	ldi	r23, 0x01	; 1
 298:	85 e1       	ldi	r24, 0x15	; 21
 29a:	91 e0       	ldi	r25, 0x01	; 1
 29c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <_ZN5ClockC1EP7DisplayNS_9ModesTypeE>
Animation wcAnimation(&wcDisplay, &wcClock);
 2a0:	45 e1       	ldi	r20, 0x15	; 21
 2a2:	51 e0       	ldi	r21, 0x01	; 1
 2a4:	68 e1       	ldi	r22, 0x18	; 24
 2a6:	71 e0       	ldi	r23, 0x01	; 1
 2a8:	80 e0       	ldi	r24, 0x00	; 0
 2aa:	91 e0       	ldi	r25, 0x01	; 1
 2ac:	0c 94 64 01 	jmp	0x2c8	; 0x2c8 <_ZN9AnimationC1EP7DisplayP5Clock>

000002b0 <_GLOBAL__sub_D_flag>:
 2b0:	80 e0       	ldi	r24, 0x00	; 0
 2b2:	91 e0       	ldi	r25, 0x01	; 1
 2b4:	0e 94 93 01 	call	0x326	; 0x326 <_ZN9AnimationD1Ev>
#include "Animation.h"
#include "Clock.h"
/*End of auto generated code by Atmel studio */
int flag;
Display wcDisplay(20, 20, 20);
Clock wcClock(&wcDisplay, Clock::MODE_WESSI);
 2b8:	85 e1       	ldi	r24, 0x15	; 21
 2ba:	91 e0       	ldi	r25, 0x01	; 1
 2bc:	0e 94 57 02 	call	0x4ae	; 0x4ae <_ZN5ClockD1Ev>
#include "Display.h"
#include "Animation.h"
#include "Clock.h"
/*End of auto generated code by Atmel studio */
int flag;
Display wcDisplay(20, 20, 20);
 2c0:	88 e1       	ldi	r24, 0x18	; 24
 2c2:	91 e0       	ldi	r25, 0x01	; 1
 2c4:	0c 94 3a 03 	jmp	0x674	; 0x674 <_ZN7DisplayD1Ev>

000002c8 <_ZN9AnimationC1EP7DisplayP5Clock>:
 *  \details
 *
 *  \return         -
******************************************************************************************************************************************************/
void Animation::init()
{
 2c8:	cf 92       	push	r12
 2ca:	df 92       	push	r13
 2cc:	ef 92       	push	r14
 2ce:	ff 92       	push	r15
 2d0:	0f 93       	push	r16
 2d2:	1f 93       	push	r17
 2d4:	cf 93       	push	r28
 2d6:	df 93       	push	r29
 2d8:	cd b7       	in	r28, 0x3d	; 61
 2da:	de b7       	in	r29, 0x3e	; 62
 2dc:	60 97       	sbiw	r28, 0x10	; 16
 2de:	0f b6       	in	r0, 0x3f	; 63
 2e0:	f8 94       	cli
 2e2:	de bf       	out	0x3e, r29	; 62
 2e4:	0f be       	out	0x3f, r0	; 63
 2e6:	cd bf       	out	0x3d, r28	; 61
 2e8:	8c 01       	movw	r16, r24
 2ea:	6b 01       	movw	r12, r22
 2ec:	7a 01       	movw	r14, r20
 2ee:	ce 01       	movw	r24, r28
 2f0:	01 96       	adiw	r24, 0x01	; 1
 2f2:	0e 94 b1 01 	call	0x362	; 0x362 <_ZN17AnimationTeletypeC1Ev>
 2f6:	ce 01       	movw	r24, r28
 2f8:	01 96       	adiw	r24, 0x01	; 1
 2fa:	0e 94 b9 01 	call	0x372	; 0x372 <_ZN17AnimationTeletypeD1Ev>
 2fe:	f8 01       	movw	r30, r16
 300:	d1 82       	std	Z+1, r13	; 0x01
 302:	c0 82       	st	Z, r12
 304:	f3 82       	std	Z+3, r15	; 0x03
 306:	e2 82       	std	Z+2, r14	; 0x02
 308:	60 96       	adiw	r28, 0x10	; 16
 30a:	0f b6       	in	r0, 0x3f	; 63
 30c:	f8 94       	cli
 30e:	de bf       	out	0x3e, r29	; 62
 310:	0f be       	out	0x3f, r0	; 63
 312:	cd bf       	out	0x3d, r28	; 61
 314:	df 91       	pop	r29
 316:	cf 91       	pop	r28
 318:	1f 91       	pop	r17
 31a:	0f 91       	pop	r16
 31c:	ff 90       	pop	r15
 31e:	ef 90       	pop	r14
 320:	df 90       	pop	r13
 322:	cf 90       	pop	r12
 324:	08 95       	ret

00000326 <_ZN9AnimationD1Ev>:
 326:	08 95       	ret

00000328 <_ZN9Animation12setAnimationENS_13AnimationTypeE>:
 *
 *  \return         -
******************************************************************************************************************************************************/
void Animation::setAnimation(AnimationType Animation)
{
    CurrentAnimation = Animation;
 328:	fc 01       	movw	r30, r24
 32a:	64 83       	std	Z+4, r22	; 0x04

    switch(Animation)
 32c:	61 11       	cpse	r22, r1
 32e:	07 c0       	rjmp	.+14     	; 0x33e <_ZN9Animation12setAnimationENS_13AnimationTypeE+0x16>
    {
        case ANIMATION_TELETYPE :
            Animations.Teletype.init(pDisplay, pClock);
 330:	42 81       	ldd	r20, Z+2	; 0x02
 332:	53 81       	ldd	r21, Z+3	; 0x03
 334:	60 81       	ld	r22, Z
 336:	71 81       	ldd	r23, Z+1	; 0x01
 338:	05 96       	adiw	r24, 0x05	; 5
 33a:	0c 94 ba 01 	jmp	0x374	; 0x374 <_ZN17AnimationTeletype4initEP7DisplayP5Clock>
 33e:	08 95       	ret

00000340 <_ZN9Animation8setClockEhh>:
 *
 *  \return         -
******************************************************************************************************************************************************/
stdReturnType Animation::setClock(byte Hour, byte Minute)
{
    switch(CurrentAnimation)
 340:	fc 01       	movw	r30, r24
 342:	24 81       	ldd	r18, Z+4	; 0x04
 344:	21 11       	cpse	r18, r1
 346:	03 c0       	rjmp	.+6      	; 0x34e <_ZN9Animation8setClockEhh+0xe>
    {
        case ANIMATION_TELETYPE :
            return Animations.Teletype.setClock(Hour, Minute);
 348:	05 96       	adiw	r24, 0x05	; 5
 34a:	0c 94 c2 01 	jmp	0x384	; 0x384 <_ZN17AnimationTeletype8setClockEhh>
            break;
        default :
            break;
    }
    return E_NOT_OK;
} /* setClock */
 34e:	81 e0       	ldi	r24, 0x01	; 1
 350:	08 95       	ret

00000352 <_ZN9Animation4taskEv>:
 *
 *  \return         -
******************************************************************************************************************************************************/
void Animation::task()
{
    switch(CurrentAnimation)
 352:	fc 01       	movw	r30, r24
 354:	24 81       	ldd	r18, Z+4	; 0x04
 356:	21 11       	cpse	r18, r1
 358:	03 c0       	rjmp	.+6      	; 0x360 <_ZN9Animation4taskEv+0xe>
    {
        case ANIMATION_TELETYPE :
            return Animations.Teletype.task();
 35a:	05 96       	adiw	r24, 0x05	; 5
 35c:	0c 94 0c 02 	jmp	0x418	; 0x418 <_ZN17AnimationTeletype4taskEv>
 360:	08 95       	ret

00000362 <_ZN17AnimationTeletypeC1Ev>:
{
    for(auto& Word : ClockWordsTable) { Word = Display::WORD_NONE; }
    CurrentWordIndex = 0;
    CurrentWordLength = 0;
    CurrentCharIndex = 0;
    UseCursor = false;
 362:	fc 01       	movw	r30, r24
 364:	13 82       	std	Z+3, r1	; 0x03
 366:	12 82       	std	Z+2, r1	; 0x02
 368:	11 82       	std	Z+1, r1	; 0x01
 36a:	10 82       	st	Z, r1
 36c:	81 e0       	ldi	r24, 0x01	; 1
 36e:	84 83       	std	Z+4, r24	; 0x04
 370:	08 95       	ret

00000372 <_ZN17AnimationTeletypeD1Ev>:
 372:	08 95       	ret

00000374 <_ZN17AnimationTeletype4initEP7DisplayP5Clock>:
 374:	fc 01       	movw	r30, r24
 376:	73 83       	std	Z+3, r23	; 0x03
 378:	62 83       	std	Z+2, r22	; 0x02
 37a:	51 83       	std	Z+1, r21	; 0x01
 37c:	40 83       	st	Z, r20
 37e:	82 e0       	ldi	r24, 0x02	; 2
 380:	84 83       	std	Z+4, r24	; 0x04
 382:	08 95       	ret

00000384 <_ZN17AnimationTeletype8setClockEhh>:
 384:	0f 93       	push	r16
 386:	1f 93       	push	r17
 388:	cf 93       	push	r28
 38a:	df 93       	push	r29
 38c:	00 d0       	rcall	.+0      	; 0x38e <_ZN17AnimationTeletype8setClockEhh+0xa>
 38e:	1f 92       	push	r1
 390:	cd b7       	in	r28, 0x3d	; 61
 392:	de b7       	in	r29, 0x3e	; 62
 394:	8c 01       	movw	r16, r24
 396:	9c 01       	movw	r18, r24
 398:	2b 5f       	subi	r18, 0xFB	; 251
 39a:	3f 4f       	sbci	r19, 0xFF	; 255
 39c:	fc 01       	movw	r30, r24
 39e:	80 81       	ld	r24, Z
 3a0:	91 81       	ldd	r25, Z+1	; 0x01
 3a2:	0e 94 c9 02 	call	0x592	; 0x592 <_ZN5Clock13getClockWordsEhhPN7Display8WordTypeE>
 3a6:	81 11       	cpse	r24, r1
 3a8:	04 c0       	rjmp	.+8      	; 0x3b2 <_ZN17AnimationTeletype8setClockEhh+0x2e>
 3aa:	f8 01       	movw	r30, r16
 3ac:	84 81       	ldd	r24, Z+4	; 0x04
 3ae:	82 30       	cpi	r24, 0x02	; 2
 3b0:	11 f0       	breq	.+4      	; 0x3b6 <_ZN17AnimationTeletype8setClockEhh+0x32>
 3b2:	81 e0       	ldi	r24, 0x01	; 1
 3b4:	18 c0       	rjmp	.+48     	; 0x3e6 <_ZN17AnimationTeletype8setClockEhh+0x62>
 3b6:	f8 01       	movw	r30, r16
 3b8:	14 86       	std	Z+12, r1	; 0x0c
 3ba:	16 86       	std	Z+14, r1	; 0x0e
 3bc:	65 81       	ldd	r22, Z+5	; 0x05
 3be:	70 e0       	ldi	r23, 0x00	; 0
 3c0:	cb 01       	movw	r24, r22
 3c2:	88 0f       	add	r24, r24
 3c4:	99 1f       	adc	r25, r25
 3c6:	68 0f       	add	r22, r24
 3c8:	79 1f       	adc	r23, r25
 3ca:	68 57       	subi	r22, 0x78	; 120
 3cc:	7e 4f       	sbci	r23, 0xFE	; 254
 3ce:	43 e0       	ldi	r20, 0x03	; 3
 3d0:	50 e0       	ldi	r21, 0x00	; 0
 3d2:	ce 01       	movw	r24, r28
 3d4:	01 96       	adiw	r24, 0x01	; 1
 3d6:	0e 94 c1 05 	call	0xb82	; 0xb82 <memcpy_P>
 3da:	8b 81       	ldd	r24, Y+3	; 0x03
 3dc:	f8 01       	movw	r30, r16
 3de:	85 87       	std	Z+13, r24	; 0x0d
 3e0:	83 e0       	ldi	r24, 0x03	; 3
 3e2:	84 83       	std	Z+4, r24	; 0x04
 3e4:	80 e0       	ldi	r24, 0x00	; 0
 3e6:	0f 90       	pop	r0
 3e8:	0f 90       	pop	r0
 3ea:	0f 90       	pop	r0
 3ec:	df 91       	pop	r29
 3ee:	cf 91       	pop	r28
 3f0:	1f 91       	pop	r17
 3f2:	0f 91       	pop	r16
 3f4:	08 95       	ret

000003f6 <_ZN17AnimationTeletype16setNextWordIndexEv>:
 *  \details
 *
 *  \return         -
******************************************************************************************************************************************************/
stdReturnType AnimationTeletype::setNextWordIndex()
{
 3f6:	fc 01       	movw	r30, r24
    for(uint8_t Index = CurrentWordIndex + 1; Index < CLOCK_WORDS_TABLE_TYPE_SIZE; Index++)
 3f8:	94 85       	ldd	r25, Z+12	; 0x0c
 3fa:	9f 5f       	subi	r25, 0xFF	; 255
 3fc:	97 30       	cpi	r25, 0x07	; 7
 3fe:	50 f4       	brcc	.+20     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
    {
        if(ClockWordsTable[Index] != Display::WORD_NONE) {
 400:	df 01       	movw	r26, r30
 402:	a9 0f       	add	r26, r25
 404:	b1 1d       	adc	r27, r1
 406:	15 96       	adiw	r26, 0x05	; 5
 408:	8c 91       	ld	r24, X
 40a:	88 23       	and	r24, r24
 40c:	b1 f3       	breq	.-20     	; 0x3fa <_ZN17AnimationTeletype16setNextWordIndexEv+0x4>
            CurrentWordIndex = Index;
 40e:	94 87       	std	Z+12, r25	; 0x0c
            return E_OK;
 410:	80 e0       	ldi	r24, 0x00	; 0
 412:	08 95       	ret
        }
    }
    return E_NOT_OK;
 414:	81 e0       	ldi	r24, 0x01	; 1
} /* setNextWordIndex */
 416:	08 95       	ret

00000418 <_ZN17AnimationTeletype4taskEv>:
 *  \details        
 *                  
 *  \return         -
******************************************************************************************************************************************************/
void AnimationTeletype::task()
{
 418:	0f 93       	push	r16
 41a:	1f 93       	push	r17
 41c:	cf 93       	push	r28
 41e:	df 93       	push	r29
 420:	00 d0       	rcall	.+0      	; 0x422 <_ZN17AnimationTeletype4taskEv+0xa>
 422:	1f 92       	push	r1
 424:	cd b7       	in	r28, 0x3d	; 61
 426:	de b7       	in	r29, 0x3e	; 62
    if(State == STATE_WORKING) {
 428:	fc 01       	movw	r30, r24
 42a:	24 81       	ldd	r18, Z+4	; 0x04
 42c:	23 30       	cpi	r18, 0x03	; 3
 42e:	91 f5       	brne	.+100    	; 0x494 <_ZN17AnimationTeletype4taskEv+0x7c>
 430:	8c 01       	movw	r16, r24
        if(CurrentCharIndex >= CurrentWordLength) {
 432:	96 85       	ldd	r25, Z+14	; 0x0e
 434:	85 85       	ldd	r24, Z+13	; 0x0d
 436:	98 17       	cp	r25, r24
 438:	00 f1       	brcs	.+64     	; 0x47a <_ZN17AnimationTeletype4taskEv+0x62>
            if(setNextWordIndex() == E_NOT_OK) {
 43a:	cf 01       	movw	r24, r30
 43c:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <_ZN17AnimationTeletype16setNextWordIndexEv>
 440:	81 30       	cpi	r24, 0x01	; 1
 442:	21 f4       	brne	.+8      	; 0x44c <_ZN17AnimationTeletype4taskEv+0x34>
                State = STATE_IDLE;
 444:	82 e0       	ldi	r24, 0x02	; 2
 446:	f8 01       	movw	r30, r16
 448:	84 83       	std	Z+4, r24	; 0x04
                return;
 44a:	24 c0       	rjmp	.+72     	; 0x494 <_ZN17AnimationTeletype4taskEv+0x7c>
            }
            CurrentCharIndex = 0;
 44c:	f8 01       	movw	r30, r16
 44e:	16 86       	std	Z+14, r1	; 0x0e
            CurrentWordLength = pDisplay->getWordLengthFast(ClockWordsTable[CurrentWordIndex]);
 450:	84 85       	ldd	r24, Z+12	; 0x0c
 452:	e8 0f       	add	r30, r24
 454:	f1 1d       	adc	r31, r1
    stdReturnType setWord(WordType, byte MaxLength = DISPLAY_WORD_LENGTH_UNLIMITED);
    stdReturnType clearWord(WordType);
    stdReturnType clearAllWords();

    // word methods fast
    WordIlluminationType getWordIlluminationFast(WordType Word) const { WordIlluminationType WordIllu; memcpy_P(&WordIllu, &WordIlluminationTable[Word], sizeof(WordIllu)); return WordIllu; }
 456:	65 81       	ldd	r22, Z+5	; 0x05
 458:	70 e0       	ldi	r23, 0x00	; 0
 45a:	cb 01       	movw	r24, r22
 45c:	88 0f       	add	r24, r24
 45e:	99 1f       	adc	r25, r25
 460:	68 0f       	add	r22, r24
 462:	79 1f       	adc	r23, r25
 464:	68 57       	subi	r22, 0x78	; 120
 466:	7e 4f       	sbci	r23, 0xFE	; 254
 468:	43 e0       	ldi	r20, 0x03	; 3
 46a:	50 e0       	ldi	r21, 0x00	; 0
 46c:	ce 01       	movw	r24, r28
 46e:	01 96       	adiw	r24, 0x01	; 1
 470:	0e 94 c1 05 	call	0xb82	; 0xb82 <memcpy_P>
 474:	8b 81       	ldd	r24, Y+3	; 0x03
 476:	f8 01       	movw	r30, r16
 478:	85 87       	std	Z+13, r24	; 0x0d
        }
        CurrentCharIndex++;
 47a:	f8 01       	movw	r30, r16
 47c:	46 85       	ldd	r20, Z+14	; 0x0e
 47e:	4f 5f       	subi	r20, 0xFF	; 255
 480:	46 87       	std	Z+14, r20	; 0x0e
        pDisplay->setWordFast(ClockWordsTable[CurrentWordIndex], CurrentCharIndex);
 482:	84 85       	ldd	r24, Z+12	; 0x0c
 484:	e8 0f       	add	r30, r24
 486:	f1 1d       	adc	r31, r1
 488:	65 81       	ldd	r22, Z+5	; 0x05
 48a:	f8 01       	movw	r30, r16
 48c:	82 81       	ldd	r24, Z+2	; 0x02
 48e:	93 81       	ldd	r25, Z+3	; 0x03
 490:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <_ZN7Display11setWordFastENS_8WordTypeEh>
    }
} /* task */
 494:	0f 90       	pop	r0
 496:	0f 90       	pop	r0
 498:	0f 90       	pop	r0
 49a:	df 91       	pop	r29
 49c:	cf 91       	pop	r28
 49e:	1f 91       	pop	r17
 4a0:	0f 91       	pop	r16
 4a2:	08 95       	ret

000004a4 <_ZN5ClockC1EP7DisplayNS_9ModesTypeE>:
 *
 *  \return         -
******************************************************************************************************************************************************/
Clock::Clock(Display* Display, ModesType sMode)
{
    pDisplay = Display;
 4a4:	fc 01       	movw	r30, r24
 4a6:	71 83       	std	Z+1, r23	; 0x01
 4a8:	60 83       	st	Z, r22
    Mode = sMode;
 4aa:	42 83       	std	Z+2, r20	; 0x02
 4ac:	08 95       	ret

000004ae <_ZN5ClockD1Ev>:


/******************************************************************************************************************************************************
  DESTRUCTOR OF Clock
******************************************************************************************************************************************************/
Clock::~Clock()
 4ae:	08 95       	ret

000004b0 <_ZN5Clock13getClockWordsEhhPNS_14ClockWordsTypeE>:
 *  \details
 *
 *  \return         -
******************************************************************************************************************************************************/
stdReturnType Clock::getClockWords(byte Hour, byte Minute, ClockWordsType* ClockWords)
{
 4b0:	ef 92       	push	r14
 4b2:	ff 92       	push	r15
 4b4:	0f 93       	push	r16
 4b6:	1f 93       	push	r17
 4b8:	cf 93       	push	r28
 4ba:	df 93       	push	r29
 4bc:	cd b7       	in	r28, 0x3d	; 61
 4be:	de b7       	in	r29, 0x3e	; 62
 4c0:	2a 97       	sbiw	r28, 0x0a	; 10
 4c2:	0f b6       	in	r0, 0x3f	; 63
 4c4:	f8 94       	cli
 4c6:	de bf       	out	0x3e, r29	; 62
 4c8:	0f be       	out	0x3f, r0	; 63
 4ca:	cd bf       	out	0x3d, r28	; 61
 4cc:	fc 01       	movw	r30, r24
 4ce:	f6 2e       	mov	r15, r22
 4d0:	84 2f       	mov	r24, r20
 4d2:	89 01       	movw	r16, r18
    /* ----- Local Variables ---------------------------------------------- */
    stdReturnType ReturnValue{E_NOT_OK};

    /* ----- Implementation ----------------------------------------------- */
    if(Hour < CLOCK_NUMBER_OF_HOURS_PER_DAY && Minute < CLOCK_NUMBER_OF_MINUTES_PER_HOUR) {
 4d4:	97 e1       	ldi	r25, 0x17	; 23
 4d6:	96 17       	cp	r25, r22
 4d8:	08 f4       	brcc	.+2      	; 0x4dc <_ZN5Clock13getClockWordsEhhPNS_14ClockWordsTypeE+0x2c>
 4da:	4d c0       	rjmp	.+154    	; 0x576 <_ZN5Clock13getClockWordsEhhPNS_14ClockWordsTypeE+0xc6>
 4dc:	4c 33       	cpi	r20, 0x3C	; 60
 4de:	08 f0       	brcs	.+2      	; 0x4e2 <_ZN5Clock13getClockWordsEhhPNS_14ClockWordsTypeE+0x32>
 4e0:	4a c0       	rjmp	.+148    	; 0x576 <_ZN5Clock13getClockWordsEhhPNS_14ClockWordsTypeE+0xc6>
        ReturnValue = E_OK;
        /* show IT IS permanently or only to full and half hour */
#if (CLOCK_SHOW_IT_IS_PERMANENTLY == STD_ON)
        ClockWords->ShowItIs = true;
 4e2:	91 e0       	ldi	r25, 0x01	; 1
 4e4:	d9 01       	movw	r26, r18
 4e6:	9c 93       	st	X, r25
    static const MinutesType MinutesTable[][CLOCK_NUMBER_OF_MINUTE_STEPS];
    
    // functions
    inline MinutesTableEntryType getMinutesTableEntry(ModesType Mode, byte Minute) {
        MinutesTableEntryType MinutesTableEntry;
        memcpy_P(&MinutesTableEntry, &MinutesTable[Mode][Minute / CLOCK_MINUTE_STEP_IN_MINUTES], sizeof(MinutesType));
 4e8:	95 e0       	ldi	r25, 0x05	; 5
 4ea:	e9 2e       	mov	r14, r25
 4ec:	6e 2d       	mov	r22, r14
 4ee:	0e 94 af 05 	call	0xb5e	; 0xb5e <__udivmodqi4>
 4f2:	62 81       	ldd	r22, Z+2	; 0x02
 4f4:	bc e3       	ldi	r27, 0x3C	; 60
 4f6:	6b 9f       	mul	r22, r27
 4f8:	b0 01       	movw	r22, r0
 4fa:	11 24       	eor	r1, r1
 4fc:	e8 9e       	mul	r14, r24
 4fe:	60 0d       	add	r22, r0
 500:	71 1d       	adc	r23, r1
 502:	11 24       	eor	r1, r1
 504:	68 59       	subi	r22, 0x98	; 152
 506:	7f 4f       	sbci	r23, 0xFF	; 255
 508:	45 e0       	ldi	r20, 0x05	; 5
 50a:	50 e0       	ldi	r21, 0x00	; 0
 50c:	ce 01       	movw	r24, r28
 50e:	06 96       	adiw	r24, 0x06	; 6
 510:	0e 94 c1 05 	call	0xb82	; 0xb82 <memcpy_P>
        return MinutesTableEntry;
 514:	fe 01       	movw	r30, r28
 516:	36 96       	adiw	r30, 0x06	; 6
 518:	de 01       	movw	r26, r28
 51a:	11 96       	adiw	r26, 0x01	; 1
 51c:	01 90       	ld	r0, Z+
 51e:	0d 92       	st	X+, r0
 520:	ea 94       	dec	r14
 522:	e1 f7       	brne	.-8      	; 0x51c <_ZN5Clock13getClockWordsEhhPNS_14ClockWordsTypeE+0x6c>
 524:	89 81       	ldd	r24, Y+1	; 0x01
 526:	6a 81       	ldd	r22, Y+2	; 0x02
 528:	2c 81       	ldd	r18, Y+4	; 0x04
 52a:	9d 81       	ldd	r25, Y+5	; 0x05
        }
#endif
        MinutesTableEntryType MinutesTableEntry = getMinutesTableEntry(Mode, Minute);

        for(byte Index = 0; Index < CLOCK_MAX_NUMBER_OF_MINUTE_WORDS; Index++) {
            ClockWords->MinuteWords[Index] = MinutesTableEntry.Words[Index];
 52c:	3b 81       	ldd	r19, Y+3	; 0x03
 52e:	f8 01       	movw	r30, r16
 530:	33 83       	std	Z+3, r19	; 0x03
 532:	24 83       	std	Z+4, r18	; 0x04
 534:	95 83       	std	Z+5, r25	; 0x05
        }

        if(Hour >= CLOCK_NUMBER_OF_HOURS) Hour -= CLOCK_NUMBER_OF_HOURS;
 536:	fb e0       	ldi	r31, 0x0B	; 11
 538:	ff 15       	cp	r31, r15
 53a:	10 f4       	brcc	.+4      	; 0x540 <_ZN5Clock13getClockWordsEhhPNS_14ClockWordsTypeE+0x90>
 53c:	94 ef       	ldi	r25, 0xF4	; 244
 53e:	f9 0e       	add	r15, r25
        Hour += MinutesTableEntry.HourOffset;                             // correct the hour offset from the minutes
 540:	6f 0d       	add	r22, r15
        if(Hour >= CLOCK_NUMBER_OF_HOURS) Hour -= CLOCK_NUMBER_OF_HOURS;
 542:	6c 30       	cpi	r22, 0x0C	; 12
 544:	08 f0       	brcs	.+2      	; 0x548 <_ZN5Clock13getClockWordsEhhPNS_14ClockWordsTypeE+0x98>
 546:	6c 50       	subi	r22, 0x0C	; 12
    }
    inline HoursTableEntryType getHoursTableEntry(HourModesType HourMode, byte Hour) {
        HoursTableEntryType HoursTableEntry;
        memcpy_P(&HoursTableEntry, &HoursTable[HourMode][Hour], sizeof(HoursType));
 548:	70 e0       	ldi	r23, 0x00	; 0
 54a:	ac e0       	ldi	r26, 0x0C	; 12
 54c:	8a 9f       	mul	r24, r26
 54e:	60 0d       	add	r22, r0
 550:	71 1d       	adc	r23, r1
 552:	11 24       	eor	r1, r1
 554:	66 0f       	add	r22, r22
 556:	77 1f       	adc	r23, r23
 558:	68 5a       	subi	r22, 0xA8	; 168
 55a:	7e 4f       	sbci	r23, 0xFE	; 254
 55c:	42 e0       	ldi	r20, 0x02	; 2
 55e:	50 e0       	ldi	r21, 0x00	; 0
 560:	ce 01       	movw	r24, r28
 562:	06 96       	adiw	r24, 0x06	; 6
 564:	0e 94 c1 05 	call	0xb82	; 0xb82 <memcpy_P>
        return HoursTableEntry;
 568:	9e 81       	ldd	r25, Y+6	; 0x06
 56a:	8f 81       	ldd	r24, Y+7	; 0x07

        HoursTableEntryType HoursTableEntry = getHoursTableEntry(MinutesTableEntry.HourMode, Hour);

        for(byte Index = 0; Index < CLOCK_MAX_NUMBER_OF_HOUR_WORDS; Index++) {
            ClockWords->HourWords[Index] = HoursTableEntry.Words[Index];
 56c:	f8 01       	movw	r30, r16
 56e:	91 83       	std	Z+1, r25	; 0x01
 570:	82 83       	std	Z+2, r24	; 0x02
 572:	80 e0       	ldi	r24, 0x00	; 0
 574:	01 c0       	rjmp	.+2      	; 0x578 <_ZN5Clock13getClockWordsEhhPNS_14ClockWordsTypeE+0xc8>
        }
    } else {
        ReturnValue = E_NOT_OK;
 576:	81 e0       	ldi	r24, 0x01	; 1
    }
    return ReturnValue;
} /* getClockWords */
 578:	2a 96       	adiw	r28, 0x0a	; 10
 57a:	0f b6       	in	r0, 0x3f	; 63
 57c:	f8 94       	cli
 57e:	de bf       	out	0x3e, r29	; 62
 580:	0f be       	out	0x3f, r0	; 63
 582:	cd bf       	out	0x3d, r28	; 61
 584:	df 91       	pop	r29
 586:	cf 91       	pop	r28
 588:	1f 91       	pop	r17
 58a:	0f 91       	pop	r16
 58c:	ff 90       	pop	r15
 58e:	ef 90       	pop	r14
 590:	08 95       	ret

00000592 <_ZN5Clock13getClockWordsEhhPN7Display8WordTypeE>:
 *  \details
 *
 *  \return         -
******************************************************************************************************************************************************/
stdReturnType Clock::getClockWords(byte Hour, byte Minute, ClockWordsTableType ClockWordsTable)
{
 592:	0f 93       	push	r16
 594:	1f 93       	push	r17
 596:	cf 93       	push	r28
 598:	df 93       	push	r29
 59a:	00 d0       	rcall	.+0      	; 0x59c <_ZN5Clock13getClockWordsEhhPN7Display8WordTypeE+0xa>
 59c:	00 d0       	rcall	.+0      	; 0x59e <_ZN5Clock13getClockWordsEhhPN7Display8WordTypeE+0xc>
 59e:	00 d0       	rcall	.+0      	; 0x5a0 <_ZN5Clock13getClockWordsEhhPN7Display8WordTypeE+0xe>
 5a0:	cd b7       	in	r28, 0x3d	; 61
 5a2:	de b7       	in	r29, 0x3e	; 62
 5a4:	89 01       	movw	r16, r18
    ClockWordsType ClockWords;
    stdReturnType ReturnValue{E_OK};

    if(getClockWords(Hour, Minute, &ClockWords) == E_NOT_OK) ReturnValue = E_NOT_OK;
 5a6:	9e 01       	movw	r18, r28
 5a8:	2f 5f       	subi	r18, 0xFF	; 255
 5aa:	3f 4f       	sbci	r19, 0xFF	; 255
 5ac:	0e 94 58 02 	call	0x4b0	; 0x4b0 <_ZN5Clock13getClockWordsEhhPNS_14ClockWordsTypeE>
 *  \return         -
******************************************************************************************************************************************************/
stdReturnType Clock::getClockWords(byte Hour, byte Minute, ClockWordsTableType ClockWordsTable)
{
    ClockWordsType ClockWords;
    stdReturnType ReturnValue{E_OK};
 5b0:	91 e0       	ldi	r25, 0x01	; 1
 5b2:	81 30       	cpi	r24, 0x01	; 1
 5b4:	09 f0       	breq	.+2      	; 0x5b8 <_ZN5Clock13getClockWordsEhhPN7Display8WordTypeE+0x26>
 5b6:	90 e0       	ldi	r25, 0x00	; 0

    if(getClockWords(Hour, Minute, &ClockWords) == E_NOT_OK) ReturnValue = E_NOT_OK;

    if(ClockWords.ShowItIs) {
 5b8:	89 81       	ldd	r24, Y+1	; 0x01
 5ba:	88 23       	and	r24, r24
 5bc:	31 f0       	breq	.+12     	; 0x5ca <_ZN5Clock13getClockWordsEhhPN7Display8WordTypeE+0x38>
        ClockWordsTable[0] = Display::WORD_ES;
 5be:	81 e0       	ldi	r24, 0x01	; 1
 5c0:	f8 01       	movw	r30, r16
 5c2:	80 83       	st	Z, r24
        ClockWordsTable[1] = Display::WORD_IST;
 5c4:	82 e0       	ldi	r24, 0x02	; 2
 5c6:	81 83       	std	Z+1, r24	; 0x01
 5c8:	03 c0       	rjmp	.+6      	; 0x5d0 <_ZN5Clock13getClockWordsEhhPN7Display8WordTypeE+0x3e>
    } else {
        ClockWordsTable[0] = Display::WORD_NONE;
 5ca:	f8 01       	movw	r30, r16
 5cc:	10 82       	st	Z, r1
        ClockWordsTable[1] = Display::WORD_NONE;
 5ce:	11 82       	std	Z+1, r1	; 0x01
    }

    ClockWordsTable[2] = ClockWords.MinuteWords[0];
 5d0:	8c 81       	ldd	r24, Y+4	; 0x04
 5d2:	f8 01       	movw	r30, r16
 5d4:	82 83       	std	Z+2, r24	; 0x02
    ClockWordsTable[3] = ClockWords.MinuteWords[1];
 5d6:	8d 81       	ldd	r24, Y+5	; 0x05
 5d8:	83 83       	std	Z+3, r24	; 0x03
    ClockWordsTable[4] = ClockWords.MinuteWords[2];
 5da:	8e 81       	ldd	r24, Y+6	; 0x06
 5dc:	84 83       	std	Z+4, r24	; 0x04
    ClockWordsTable[5] = ClockWords.HourWords[0];
 5de:	8a 81       	ldd	r24, Y+2	; 0x02
 5e0:	85 83       	std	Z+5, r24	; 0x05
    ClockWordsTable[6] = ClockWords.HourWords[1];
 5e2:	8b 81       	ldd	r24, Y+3	; 0x03
 5e4:	86 83       	std	Z+6, r24	; 0x06

    return ReturnValue;

} /* getClockWords */
 5e6:	89 2f       	mov	r24, r25
 5e8:	26 96       	adiw	r28, 0x06	; 6
 5ea:	0f b6       	in	r0, 0x3f	; 63
 5ec:	f8 94       	cli
 5ee:	de bf       	out	0x3e, r29	; 62
 5f0:	0f be       	out	0x3f, r0	; 63
 5f2:	cd bf       	out	0x3d, r28	; 61
 5f4:	df 91       	pop	r29
 5f6:	cf 91       	pop	r28
 5f8:	1f 91       	pop	r17
 5fa:	0f 91       	pop	r16
 5fc:	08 95       	ret

000005fe <_ZNK7Display23getWordIlluminationFastENS_8WordTypeE.isra.1>:
stdReturnType Display::setPixel(byte Index)
{
    byte Row = Index / DISPLAY_NUMBER_OF_COLUMNS;
    byte Column = Index % DISPLAY_NUMBER_OF_COLUMNS;

    return setPixel(Column,  Row);
 5fe:	cf 93       	push	r28
 600:	df 93       	push	r29
 602:	00 d0       	rcall	.+0      	; 0x604 <_ZNK7Display23getWordIlluminationFastENS_8WordTypeE.isra.1+0x6>
 604:	1f 92       	push	r1
 606:	cd b7       	in	r28, 0x3d	; 61
 608:	de b7       	in	r29, 0x3e	; 62
 60a:	90 e0       	ldi	r25, 0x00	; 0
 60c:	bc 01       	movw	r22, r24
 60e:	66 0f       	add	r22, r22
 610:	77 1f       	adc	r23, r23
 612:	86 0f       	add	r24, r22
 614:	97 1f       	adc	r25, r23
 616:	bc 01       	movw	r22, r24
 618:	68 57       	subi	r22, 0x78	; 120
 61a:	7e 4f       	sbci	r23, 0xFE	; 254
 61c:	43 e0       	ldi	r20, 0x03	; 3
 61e:	50 e0       	ldi	r21, 0x00	; 0
 620:	ce 01       	movw	r24, r28
 622:	01 96       	adiw	r24, 0x01	; 1
 624:	0e 94 c1 05 	call	0xb82	; 0xb82 <memcpy_P>
 628:	69 81       	ldd	r22, Y+1	; 0x01
 62a:	7a 81       	ldd	r23, Y+2	; 0x02
 62c:	8b 81       	ldd	r24, Y+3	; 0x03
 62e:	0f 90       	pop	r0
 630:	0f 90       	pop	r0
 632:	0f 90       	pop	r0
 634:	df 91       	pop	r29
 636:	cf 91       	pop	r28
 638:	08 95       	ret

0000063a <_ZN7DisplayC1Ehhh>:
 63a:	ff 92       	push	r15
 63c:	0f 93       	push	r16
 63e:	1f 93       	push	r17
 640:	cf 93       	push	r28
 642:	df 93       	push	r29
 644:	ec 01       	movw	r28, r24
 646:	f6 2e       	mov	r15, r22
 648:	04 2f       	mov	r16, r20
 64a:	12 2f       	mov	r17, r18
 64c:	6a e0       	ldi	r22, 0x0A	; 10
 64e:	01 96       	adiw	r24, 0x01	; 1
 650:	0e 94 9e 03 	call	0x73c	; 0x73c <_ZN6WS2812C1Eh>
 654:	fe 01       	movw	r30, r28
 656:	ea 5a       	subi	r30, 0xAA	; 170
 658:	fe 4f       	sbci	r31, 0xFE	; 254
 65a:	f0 82       	st	Z, r15
 65c:	31 96       	adiw	r30, 0x01	; 1
 65e:	00 83       	st	Z, r16
 660:	31 96       	adiw	r30, 0x01	; 1
 662:	10 83       	st	Z, r17
 664:	81 e0       	ldi	r24, 0x01	; 1
 666:	88 83       	st	Y, r24
 668:	df 91       	pop	r29
 66a:	cf 91       	pop	r28
 66c:	1f 91       	pop	r17
 66e:	0f 91       	pop	r16
 670:	ff 90       	pop	r15
 672:	08 95       	ret

00000674 <_ZN7DisplayD1Ev>:
 674:	01 96       	adiw	r24, 0x01	; 1
 676:	0c 94 7c 03 	jmp	0x6f8	; 0x6f8 <_ZN6WS2812D1Ev>

0000067a <_ZNK7Display21transformToSerpentineEhh>:
 67a:	40 fd       	sbrc	r20, 0
 67c:	02 c0       	rjmp	.+4      	; 0x682 <_ZNK7Display21transformToSerpentineEhh+0x8>
 67e:	86 2f       	mov	r24, r22
 680:	02 c0       	rjmp	.+4      	; 0x686 <_ZNK7Display21transformToSerpentineEhh+0xc>
 682:	8a e0       	ldi	r24, 0x0A	; 10
 684:	86 1b       	sub	r24, r22
 686:	9b e0       	ldi	r25, 0x0B	; 11
 688:	49 9f       	mul	r20, r25
 68a:	80 0d       	add	r24, r0
 68c:	11 24       	eor	r1, r1
 68e:	08 95       	ret

00000690 <_ZN7Display12setPixelFastEhh>:
 *  \details        
 *                  
 *  \return         -
******************************************************************************************************************************************************/
void Display::setPixelFast(byte Column, byte Row)
{
 690:	cf 93       	push	r28
 692:	df 93       	push	r29
 694:	ec 01       	movw	r28, r24
#if (DISPLAY_LED_STRIPE_SERPENTINE == STD_ON)
    /* if led stripe is snake or serpentine the odd row: count from right to left */
    Pixels.setPixelFast(transformToSerpentine(Column,  Row), Color);
 696:	0e 94 3d 03 	call	0x67a	; 0x67a <_ZNK7Display21transformToSerpentineEhh>
 69a:	fe 01       	movw	r30, r28
 69c:	ea 5a       	subi	r30, 0xAA	; 170
 69e:	fe 4f       	sbci	r31, 0xFE	; 254
 6a0:	20 81       	ld	r18, Z
 6a2:	31 81       	ldd	r19, Z+1	; 0x01
 6a4:	42 81       	ldd	r20, Z+2	; 0x02
 6a6:	68 2f       	mov	r22, r24
 6a8:	ce 01       	movw	r24, r28
 6aa:	01 96       	adiw	r24, 0x01	; 1
#else
    Pixels.setPixelFast((Row * DISPLAY_NUMBER_OF_COLUMNS) + Column, Color);
#endif
} /* setPixelFast */
 6ac:	df 91       	pop	r29
 6ae:	cf 91       	pop	r28
******************************************************************************************************************************************************/
void Display::setPixelFast(byte Column, byte Row)
{
#if (DISPLAY_LED_STRIPE_SERPENTINE == STD_ON)
    /* if led stripe is snake or serpentine the odd row: count from right to left */
    Pixels.setPixelFast(transformToSerpentine(Column,  Row), Color);
 6b0:	0c 94 c4 03 	jmp	0x788	; 0x788 <_ZN6WS281212setPixelFastEh15WS2812PixelType>

000006b4 <_ZN7Display11setWordFastENS_8WordTypeEh>:
 *  \details        
 *                  
 *  \return         -
******************************************************************************************************************************************************/
void Display::setWordFast(WordType Word, byte MaxLength)
{
 6b4:	ef 92       	push	r14
 6b6:	ff 92       	push	r15
 6b8:	0f 93       	push	r16
 6ba:	1f 93       	push	r17
 6bc:	cf 93       	push	r28
 6be:	df 93       	push	r29
 6c0:	8c 01       	movw	r16, r24
 6c2:	86 2f       	mov	r24, r22
 6c4:	d4 2f       	mov	r29, r20
    byte Length;

    WordIlluminationType WordIllu = getWordIlluminationFast(Word);
 6c6:	0e 94 ff 02 	call	0x5fe	; 0x5fe <_ZNK7Display23getWordIlluminationFastENS_8WordTypeE.isra.1>
 6ca:	f6 2e       	mov	r15, r22
 6cc:	e7 2e       	mov	r14, r23

    if(MaxLength == DISPLAY_WORD_LENGTH_UNLIMITED) Length = WordIllu.Length;
 6ce:	d1 11       	cpse	r29, r1
 6d0:	01 c0       	rjmp	.+2      	; 0x6d4 <_ZN7Display11setWordFastENS_8WordTypeEh+0x20>
 6d2:	d8 2f       	mov	r29, r24
    else Length = MaxLength;

    for(byte Index = 0; Index < Length; Index++) { setPixelFast(WordIllu.Column + Index,  WordIllu.Row); }
 6d4:	c0 e0       	ldi	r28, 0x00	; 0
 6d6:	dc 17       	cp	r29, r28
 6d8:	41 f0       	breq	.+16     	; 0x6ea <_ZN7Display11setWordFastENS_8WordTypeEh+0x36>
 6da:	6c 2f       	mov	r22, r28
 6dc:	6e 0d       	add	r22, r14
 6de:	4f 2d       	mov	r20, r15
 6e0:	c8 01       	movw	r24, r16
 6e2:	0e 94 48 03 	call	0x690	; 0x690 <_ZN7Display12setPixelFastEhh>
 6e6:	cf 5f       	subi	r28, 0xFF	; 255
 6e8:	f6 cf       	rjmp	.-20     	; 0x6d6 <_ZN7Display11setWordFastENS_8WordTypeEh+0x22>
} /* setWordFast */
 6ea:	df 91       	pop	r29
 6ec:	cf 91       	pop	r28
 6ee:	1f 91       	pop	r17
 6f0:	0f 91       	pop	r16
 6f2:	ff 90       	pop	r15
 6f4:	ef 90       	pop	r14
 6f6:	08 95       	ret

000006f8 <_ZN6WS2812D1Ev>:
        Brightness = calcGamma7CorrectionValue(sBrightness / 2);
    } else {
        Brightness = sBrightness;
    }

} /* setBrightness */
 6f8:	08 95       	ret

000006fa <_ZN6WS28126setPinEh>:
 6fa:	dc 01       	movw	r26, r24
 6fc:	64 31       	cpi	r22, 0x14	; 20
 6fe:	e0 f4       	brcc	.+56     	; 0x738 <_ZN6WS28126setPinEh+0x3e>
 700:	86 2f       	mov	r24, r22
 702:	26 2f       	mov	r18, r22
 704:	30 e0       	ldi	r19, 0x00	; 0
 706:	f9 01       	movw	r30, r18
 708:	e7 52       	subi	r30, 0x27	; 39
 70a:	fe 4f       	sbci	r31, 0xFE	; 254
 70c:	e4 91       	lpm	r30, Z
 70e:	ec 93       	st	X, r30
 710:	f9 01       	movw	r30, r18
 712:	e3 51       	subi	r30, 0x13	; 19
 714:	fe 4f       	sbci	r31, 0xFE	; 254
 716:	e4 91       	lpm	r30, Z
 718:	f0 e0       	ldi	r31, 0x00	; 0
 71a:	ee 0f       	add	r30, r30
 71c:	ff 1f       	adc	r31, r31
 71e:	ef 5f       	subi	r30, 0xFF	; 255
 720:	fd 4f       	sbci	r31, 0xFD	; 253
 722:	25 91       	lpm	r18, Z+
 724:	34 91       	lpm	r19, Z
 726:	12 96       	adiw	r26, 0x02	; 2
 728:	3c 93       	st	X, r19
 72a:	2e 93       	st	-X, r18
 72c:	11 97       	sbiw	r26, 0x01	; 1
 72e:	61 e0       	ldi	r22, 0x01	; 1
 730:	0e 94 73 05 	call	0xae6	; 0xae6 <pinMode>
 734:	80 e0       	ldi	r24, 0x00	; 0
 736:	08 95       	ret
 738:	81 e0       	ldi	r24, 0x01	; 1
 73a:	08 95       	ret

0000073c <_ZN6WS2812C1Eh>:
 73c:	cf 93       	push	r28
 73e:	df 93       	push	r29
 740:	ec 01       	movw	r28, r24
 742:	0e 94 7d 03 	call	0x6fa	; 0x6fa <_ZN6WS28126setPinEh>
 746:	fe 01       	movw	r30, r28
 748:	e3 5b       	subi	r30, 0xB3	; 179
 74a:	fe 4f       	sbci	r31, 0xFE	; 254
 74c:	8f ef       	ldi	r24, 0xFF	; 255
 74e:	80 83       	st	Z, r24
 750:	31 96       	adiw	r30, 0x01	; 1
 752:	10 82       	st	Z, r1
 754:	11 82       	std	Z+1, r1	; 0x01
 756:	12 82       	std	Z+2, r1	; 0x02
 758:	13 82       	std	Z+3, r1	; 0x03
 75a:	eb 54       	subi	r30, 0x4B	; 75
 75c:	f1 40       	sbci	r31, 0x01	; 1
 75e:	8a e4       	ldi	r24, 0x4A	; 74
 760:	91 e0       	ldi	r25, 0x01	; 1
 762:	df 01       	movw	r26, r30
 764:	9c 01       	movw	r18, r24
 766:	1d 92       	st	X+, r1
 768:	21 50       	subi	r18, 0x01	; 1
 76a:	30 40       	sbci	r19, 0x00	; 0
 76c:	e1 f7       	brne	.-8      	; 0x766 <_ZN6WS2812C1Eh+0x2a>
 76e:	ef 5a       	subi	r30, 0xAF	; 175
 770:	fe 4f       	sbci	r31, 0xFE	; 254
 772:	10 82       	st	Z, r1
 774:	32 97       	sbiw	r30, 0x02	; 2
 776:	81 e0       	ldi	r24, 0x01	; 1
 778:	80 83       	st	Z, r24
 77a:	cd 5a       	subi	r28, 0xAD	; 173
 77c:	de 4f       	sbci	r29, 0xFE	; 254
 77e:	82 e0       	ldi	r24, 0x02	; 2
 780:	88 83       	st	Y, r24
 782:	df 91       	pop	r29
 784:	cf 91       	pop	r28
 786:	08 95       	ret

00000788 <_ZN6WS281212setPixelFastEh15WS2812PixelType>:
 788:	fc 01       	movw	r30, r24
 78a:	ee 5a       	subi	r30, 0xAE	; 174
 78c:	fe 4f       	sbci	r31, 0xFE	; 254
 78e:	50 81       	ld	r21, Z
 790:	fc 01       	movw	r30, r24
 792:	e6 0f       	add	r30, r22
 794:	f1 1d       	adc	r31, r1
 796:	bf 01       	movw	r22, r30
 798:	e5 0f       	add	r30, r21
 79a:	f1 1d       	adc	r31, r1
 79c:	23 83       	std	Z+3, r18	; 0x03
 79e:	fc 01       	movw	r30, r24
 7a0:	ed 5a       	subi	r30, 0xAD	; 173
 7a2:	fe 4f       	sbci	r31, 0xFE	; 254
 7a4:	20 81       	ld	r18, Z
 7a6:	fb 01       	movw	r30, r22
 7a8:	e2 0f       	add	r30, r18
 7aa:	f1 1d       	adc	r31, r1
 7ac:	33 83       	std	Z+3, r19	; 0x03
 7ae:	fc 01       	movw	r30, r24
 7b0:	ec 5a       	subi	r30, 0xAC	; 172
 7b2:	fe 4f       	sbci	r31, 0xFE	; 254
 7b4:	80 81       	ld	r24, Z
 7b6:	fb 01       	movw	r30, r22
 7b8:	e8 0f       	add	r30, r24
 7ba:	f1 1d       	adc	r31, r1
 7bc:	43 83       	std	Z+3, r20	; 0x03
 7be:	08 95       	ret

000007c0 <_ZN6WS28128sendDataEPKhj>:
{
    uint8_t BitCounter;
    uint8_t PortMaskLow;
    uint8_t PortMaskHigh;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 7c0:	3f b7       	in	r19, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 7c2:	f8 94       	cli
    {
        PortMaskLow = ~PinMask & *PortOutputRegister;
 7c4:	fc 01       	movw	r30, r24
 7c6:	20 81       	ld	r18, Z
 7c8:	a1 81       	ldd	r26, Z+1	; 0x01
 7ca:	b2 81       	ldd	r27, Z+2	; 0x02
 7cc:	9c 91       	ld	r25, X
 7ce:	82 2f       	mov	r24, r18
 7d0:	80 95       	com	r24
 7d2:	98 23       	and	r25, r24
        PortMaskHigh = PinMask | *PortOutputRegister;
 7d4:	8c 91       	ld	r24, X
 7d6:	82 2b       	or	r24, r18
 7d8:	fb 01       	movw	r30, r22
 7da:	46 0f       	add	r20, r22
 7dc:	57 1f       	adc	r21, r23

        for(uint16_t ByteCounter = 0; ByteCounter < DataLength; ByteCounter++)
 7de:	e4 17       	cp	r30, r20
 7e0:	f5 07       	cpc	r31, r21
 7e2:	81 f0       	breq	.+32     	; 0x804 <skipone885+0x8>
                : [BitCounter]      "=&d" (BitCounter)
                : [CurrentByte]     "r"   (Data[ByteCounter]),
                  [Port]            "x"   (PortOutputRegister),
                  [PortMaskHigh]    "r"   (PortMaskHigh),
                  [PortMaskLow]     "r"   (PortMaskLow)
            );
 7e4:	21 91       	ld	r18, Z+
 7e6:	68 e0       	ldi	r22, 0x08	; 8

000007e8 <loop885>:
 7e8:	8c 93       	st	X, r24
 7ea:	00 c0       	rjmp	.+0      	; 0x7ec <loop885+0x4>
 7ec:	27 ff       	sbrs	r18, 7
 7ee:	9c 93       	st	X, r25
 7f0:	22 0f       	add	r18, r18
 7f2:	00 c0       	rjmp	.+0      	; 0x7f4 <loop885+0xc>
 7f4:	00 c0       	rjmp	.+0      	; 0x7f6 <loop885+0xe>
 7f6:	00 c0       	rjmp	.+0      	; 0x7f8 <loop885+0x10>
 7f8:	08 f4       	brcc	.+2      	; 0x7fc <skipone885>
 7fa:	9c 93       	st	X, r25

000007fc <skipone885>:
 7fc:	00 c0       	rjmp	.+0      	; 0x7fe <skipone885+0x2>
 7fe:	6a 95       	dec	r22
 800:	99 f7       	brne	.-26     	; 0x7e8 <loop885>
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
    {
        PortMaskLow = ~PinMask & *PortOutputRegister;
        PortMaskHigh = PinMask | *PortOutputRegister;

        for(uint16_t ByteCounter = 0; ByteCounter < DataLength; ByteCounter++)
 802:	ed cf       	rjmp	.-38     	; 0x7de <_ZN6WS28128sendDataEPKhj+0x1e>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 804:	3f bf       	out	0x3f, r19	; 63
    __asm__ volatile ("" ::: "memory");
 806:	08 95       	ret

00000808 <_ZN6WS28124showEv.part.4>:
 *  \details        
 *                  
 *  \return         -
 *****************************************************************************************************************************************************/
#if (WS2812_RESET_TIMER == STD_ON)
stdReturnType WS2812::show()
 808:	8f 92       	push	r8
 80a:	9f 92       	push	r9
 80c:	af 92       	push	r10
 80e:	bf 92       	push	r11
 810:	cf 92       	push	r12
 812:	df 92       	push	r13
 814:	ef 92       	push	r14
 816:	ff 92       	push	r15
 818:	0f 93       	push	r16
 81a:	1f 93       	push	r17
 81c:	cf 93       	push	r28
 81e:	df 93       	push	r29
 820:	cd b7       	in	r28, 0x3d	; 61
 822:	de b7       	in	r29, 0x3e	; 62
 824:	ca 54       	subi	r28, 0x4A	; 74
 826:	d1 40       	sbci	r29, 0x01	; 1
 828:	0f b6       	in	r0, 0x3f	; 63
 82a:	f8 94       	cli
 82c:	de bf       	out	0x3e, r29	; 62
 82e:	0f be       	out	0x3f, r0	; 63
 830:	cd bf       	out	0x3d, r28	; 61
 832:	8c 01       	movw	r16, r24
    byte PixelsDimmed[WS2812_NUMBER_OF_LEDS * WS2812_NUMBER_OF_COLORS];

#if (WS2812_RESET_TIMER == STD_ON)
    if((micros() - ResetTimer) > (WS2812_RESET_DURATION_NS / 1000) || ResetTimer == 0) {
#endif
        if(Brightness != 255) {
 834:	fc 01       	movw	r30, r24
 836:	e3 5b       	subi	r30, 0xB3	; 179
 838:	fe 4f       	sbci	r31, 0xFE	; 254
 83a:	60 81       	ld	r22, Z
 83c:	6f 3f       	cpi	r22, 0xFF	; 255
 83e:	09 f4       	brne	.+2      	; 0x842 <_ZN6WS28124showEv.part.4+0x3a>
 840:	49 c0       	rjmp	.+146    	; 0x8d4 <_ZN6WS28124showEv.part.4+0xcc>
 *****************************************************************************************************************************************************/
inline void WS2812::dimmPixels(byte* PixelsDimmed, uint16_t DataLength)
{
    for(uint16_t i = 0; i < DataLength; i = i + WS2812_NUMBER_OF_COLORS)
    {
        dimmColor(&PixelsDimmed[WS2812_POS_ABS_RED(i)], Pixels[WS2812_POS_ABS_RED(i)]);
 842:	35 96       	adiw	r30, 0x05	; 5
 844:	20 81       	ld	r18, Z
 846:	30 e0       	ldi	r19, 0x00	; 0
        dimmColor(&PixelsDimmed[WS2812_POS_ABS_GREEN(i)], Pixels[WS2812_POS_ABS_GREEN(i)]);
 848:	31 96       	adiw	r30, 0x01	; 1
 84a:	e0 80       	ld	r14, Z
 84c:	f1 2c       	mov	r15, r1
        dimmColor(&PixelsDimmed[WS2812_POS_ABS_BLUE(i)], Pixels[WS2812_POS_ABS_BLUE(i)]);
 84e:	31 96       	adiw	r30, 0x01	; 1
 850:	a0 81       	ld	r26, Z
 852:	8a 2e       	mov	r8, r26
 854:	91 2c       	mov	r9, r1
 856:	e1 e0       	ldi	r30, 0x01	; 1
 858:	f0 e0       	ldi	r31, 0x00	; 0
 85a:	ec 0f       	add	r30, r28
 85c:	fd 1f       	adc	r31, r29
 85e:	e2 0f       	add	r30, r18
 860:	f3 1f       	adc	r31, r19
 862:	83 e0       	ldi	r24, 0x03	; 3
 864:	90 e0       	ldi	r25, 0x00	; 0
 *****************************************************************************************************************************************************/
inline void WS2812::dimmPixels(byte* PixelsDimmed, uint16_t DataLength)
{
    for(uint16_t i = 0; i < DataLength; i = i + WS2812_NUMBER_OF_COLORS)
    {
        dimmColor(&PixelsDimmed[WS2812_POS_ABS_RED(i)], Pixels[WS2812_POS_ABS_RED(i)]);
 866:	a9 01       	movw	r20, r18
 868:	48 0f       	add	r20, r24
 86a:	59 1f       	adc	r21, r25
 86c:	40 0f       	add	r20, r16
 86e:	51 1f       	adc	r21, r17
 870:	da 01       	movw	r26, r20
 872:	4c 91       	ld	r20, X
    void sendData(const byte*, uint16_t);
    void dimmPixels(byte*, uint16_t);
    void dimmPixel(WS2812PixelType*, WS2812PixelType);
    void dimmPixel(WS2812PixelType*, byte, byte, byte);

    void dimmColor(byte* ColorDimmed, byte Color) const { *ColorDimmed = (Color * Brightness) >> 8; }
 874:	46 9f       	mul	r20, r22
 876:	a0 01       	movw	r20, r0
 878:	11 24       	eor	r1, r1
 87a:	50 83       	st	Z, r21
        dimmColor(&PixelsDimmed[WS2812_POS_ABS_GREEN(i)], Pixels[WS2812_POS_ABS_GREEN(i)]);
 87c:	a7 01       	movw	r20, r14
 87e:	48 0f       	add	r20, r24
 880:	59 1f       	adc	r21, r25
 882:	40 0f       	add	r20, r16
 884:	51 1f       	adc	r21, r17
 886:	da 01       	movw	r26, r20
 888:	cc 90       	ld	r12, X
 88a:	af 01       	movw	r20, r30
 88c:	42 1b       	sub	r20, r18
 88e:	53 0b       	sbc	r21, r19
 890:	5a 01       	movw	r10, r20
 892:	ae 0c       	add	r10, r14
 894:	bf 1c       	adc	r11, r15
 896:	6c 9d       	mul	r22, r12
 898:	60 01       	movw	r12, r0
 89a:	11 24       	eor	r1, r1
 89c:	d5 01       	movw	r26, r10
 89e:	dc 92       	st	X, r13
        dimmColor(&PixelsDimmed[WS2812_POS_ABS_BLUE(i)], Pixels[WS2812_POS_ABS_BLUE(i)]);
 8a0:	64 01       	movw	r12, r8
 8a2:	c8 0e       	add	r12, r24
 8a4:	d9 1e       	adc	r13, r25
 8a6:	c0 0e       	add	r12, r16
 8a8:	d1 1e       	adc	r13, r17
 8aa:	d6 01       	movw	r26, r12
 8ac:	cc 90       	ld	r12, X
 8ae:	48 0d       	add	r20, r8
 8b0:	59 1d       	adc	r21, r9
 8b2:	6c 9d       	mul	r22, r12
 8b4:	60 01       	movw	r12, r0
 8b6:	11 24       	eor	r1, r1
 8b8:	da 01       	movw	r26, r20
 8ba:	dc 92       	st	X, r13
 8bc:	03 96       	adiw	r24, 0x03	; 3
 8be:	33 96       	adiw	r30, 0x03	; 3
 *                  
 *  \return         -
 *****************************************************************************************************************************************************/
inline void WS2812::dimmPixels(byte* PixelsDimmed, uint16_t DataLength)
{
    for(uint16_t i = 0; i < DataLength; i = i + WS2812_NUMBER_OF_COLORS)
 8c0:	8d 34       	cpi	r24, 0x4D	; 77
 8c2:	b1 e0       	ldi	r27, 0x01	; 1
 8c4:	9b 07       	cpc	r25, r27
 8c6:	79 f6       	brne	.-98     	; 0x866 <_ZN6WS28124showEv.part.4+0x5e>
#if (WS2812_RESET_TIMER == STD_ON)
    if((micros() - ResetTimer) > (WS2812_RESET_DURATION_NS / 1000) || ResetTimer == 0) {
#endif
        if(Brightness != 255) {
            dimmPixels(PixelsDimmed, WS2812_NUMBER_OF_LEDS * WS2812_NUMBER_OF_COLORS);
            sendData(PixelsDimmed, WS2812_NUMBER_OF_LEDS * WS2812_NUMBER_OF_COLORS);
 8c8:	4a e4       	ldi	r20, 0x4A	; 74
 8ca:	51 e0       	ldi	r21, 0x01	; 1
 8cc:	be 01       	movw	r22, r28
 8ce:	6f 5f       	subi	r22, 0xFF	; 255
 8d0:	7f 4f       	sbci	r23, 0xFF	; 255
 8d2:	05 c0       	rjmp	.+10     	; 0x8de <_ZN6WS28124showEv.part.4+0xd6>
        } else {
            sendData(Pixels, WS2812_NUMBER_OF_LEDS * WS2812_NUMBER_OF_COLORS);
 8d4:	4a e4       	ldi	r20, 0x4A	; 74
 8d6:	51 e0       	ldi	r21, 0x01	; 1
 8d8:	bc 01       	movw	r22, r24
 8da:	6d 5f       	subi	r22, 0xFD	; 253
 8dc:	7f 4f       	sbci	r23, 0xFF	; 255
 8de:	c8 01       	movw	r24, r16
 8e0:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <_ZN6WS28128sendDataEPKhj>
        }
#if (WS2812_RESET_TIMER == STD_ON)
        ResetTimer = micros();
 8e4:	0e 94 13 05 	call	0xa26	; 0xa26 <micros>
 8e8:	f8 01       	movw	r30, r16
 8ea:	e2 5b       	subi	r30, 0xB2	; 178
 8ec:	fe 4f       	sbci	r31, 0xFE	; 254
 8ee:	60 83       	st	Z, r22
 8f0:	71 83       	std	Z+1, r23	; 0x01
 8f2:	82 83       	std	Z+2, r24	; 0x02
 8f4:	93 83       	std	Z+3, r25	; 0x03
        return E_OK;
    } else {
        return E_NOT_OK;
    }
#endif
} /* show */
 8f6:	80 e0       	ldi	r24, 0x00	; 0
 8f8:	c6 5b       	subi	r28, 0xB6	; 182
 8fa:	de 4f       	sbci	r29, 0xFE	; 254
 8fc:	0f b6       	in	r0, 0x3f	; 63
 8fe:	f8 94       	cli
 900:	de bf       	out	0x3e, r29	; 62
 902:	0f be       	out	0x3f, r0	; 63
 904:	cd bf       	out	0x3d, r28	; 61
 906:	df 91       	pop	r29
 908:	cf 91       	pop	r28
 90a:	1f 91       	pop	r17
 90c:	0f 91       	pop	r16
 90e:	ff 90       	pop	r15
 910:	ef 90       	pop	r14
 912:	df 90       	pop	r13
 914:	cf 90       	pop	r12
 916:	bf 90       	pop	r11
 918:	af 90       	pop	r10
 91a:	9f 90       	pop	r9
 91c:	8f 90       	pop	r8
 91e:	08 95       	ret

00000920 <_ZN6WS28124showEv>:
#if (WS2812_RESET_TIMER == STD_ON)
stdReturnType WS2812::show()
#elif (WS2812_RESET_TIMER == STD_OFF)
void WS2812::show()
#endif
{
 920:	0f 93       	push	r16
 922:	1f 93       	push	r17
 924:	cf 93       	push	r28
 926:	df 93       	push	r29
 928:	ec 01       	movw	r28, r24
    byte PixelsDimmed[WS2812_NUMBER_OF_LEDS * WS2812_NUMBER_OF_COLORS];

#if (WS2812_RESET_TIMER == STD_ON)
    if((micros() - ResetTimer) > (WS2812_RESET_DURATION_NS / 1000) || ResetTimer == 0) {
 92a:	0e 94 13 05 	call	0xa26	; 0xa26 <micros>
 92e:	fe 01       	movw	r30, r28
 930:	e2 5b       	subi	r30, 0xB2	; 178
 932:	fe 4f       	sbci	r31, 0xFE	; 254
 934:	00 81       	ld	r16, Z
 936:	11 81       	ldd	r17, Z+1	; 0x01
 938:	22 81       	ldd	r18, Z+2	; 0x02
 93a:	33 81       	ldd	r19, Z+3	; 0x03
 93c:	dc 01       	movw	r26, r24
 93e:	cb 01       	movw	r24, r22
 940:	80 1b       	sub	r24, r16
 942:	91 0b       	sbc	r25, r17
 944:	a2 0b       	sbc	r26, r18
 946:	b3 0b       	sbc	r27, r19
 948:	c3 97       	sbiw	r24, 0x33	; 51
 94a:	a1 05       	cpc	r26, r1
 94c:	b1 05       	cpc	r27, r1
 94e:	20 f4       	brcc	.+8      	; 0x958 <_ZN6WS28124showEv+0x38>
 950:	01 2b       	or	r16, r17
 952:	02 2b       	or	r16, r18
 954:	03 2b       	or	r16, r19
 956:	39 f4       	brne	.+14     	; 0x966 <_ZN6WS28124showEv+0x46>
 958:	ce 01       	movw	r24, r28
        return E_OK;
    } else {
        return E_NOT_OK;
    }
#endif
} /* show */
 95a:	df 91       	pop	r29
 95c:	cf 91       	pop	r28
 95e:	1f 91       	pop	r17
 960:	0f 91       	pop	r16
 962:	0c 94 04 04 	jmp	0x808	; 0x808 <_ZN6WS28124showEv.part.4>
 966:	81 e0       	ldi	r24, 0x01	; 1
 968:	df 91       	pop	r29
 96a:	cf 91       	pop	r28
 96c:	1f 91       	pop	r17
 96e:	0f 91       	pop	r16
 970:	08 95       	ret

00000972 <initVariant>:
 972:	08 95       	ret

00000974 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
 974:	0e 94 38 05 	call	0xa70	; 0xa70 <init>

	initVariant();
 978:	0e 94 b9 04 	call	0x972	; 0x972 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
 97c:	0e 94 2c 01 	call	0x258	; 0x258 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 980:	c0 e0       	ldi	r28, 0x00	; 0
 982:	d0 e0       	ldi	r29, 0x00	; 0
#endif
	
	setup();
    
	for (;;) {
		loop();
 984:	0e 94 37 01 	call	0x26e	; 0x26e <loop>
		if (serialEventRun) serialEventRun();
 988:	20 97       	sbiw	r28, 0x00	; 0
 98a:	e1 f3       	breq	.-8      	; 0x984 <main+0x10>
 98c:	0e 94 00 00 	call	0	; 0x0 <__vectors>
 990:	f9 cf       	rjmp	.-14     	; 0x984 <main+0x10>

00000992 <__vector_16>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
 992:	1f 92       	push	r1
 994:	0f 92       	push	r0
 996:	0f b6       	in	r0, 0x3f	; 63
 998:	0f 92       	push	r0
 99a:	11 24       	eor	r1, r1
 99c:	2f 93       	push	r18
 99e:	3f 93       	push	r19
 9a0:	8f 93       	push	r24
 9a2:	9f 93       	push	r25
 9a4:	af 93       	push	r26
 9a6:	bf 93       	push	r27
 9a8:	80 91 72 02 	lds	r24, 0x0272	; 0x800272 <timer0_millis>
 9ac:	90 91 73 02 	lds	r25, 0x0273	; 0x800273 <timer0_millis+0x1>
 9b0:	a0 91 74 02 	lds	r26, 0x0274	; 0x800274 <timer0_millis+0x2>
 9b4:	b0 91 75 02 	lds	r27, 0x0275	; 0x800275 <timer0_millis+0x3>
 9b8:	30 91 71 02 	lds	r19, 0x0271	; 0x800271 <timer0_fract>
 9bc:	23 e0       	ldi	r18, 0x03	; 3
 9be:	23 0f       	add	r18, r19
 9c0:	2d 37       	cpi	r18, 0x7D	; 125
 9c2:	20 f4       	brcc	.+8      	; 0x9cc <__vector_16+0x3a>
 9c4:	01 96       	adiw	r24, 0x01	; 1
 9c6:	a1 1d       	adc	r26, r1
 9c8:	b1 1d       	adc	r27, r1
 9ca:	05 c0       	rjmp	.+10     	; 0x9d6 <__vector_16+0x44>
 9cc:	26 e8       	ldi	r18, 0x86	; 134
 9ce:	23 0f       	add	r18, r19
 9d0:	02 96       	adiw	r24, 0x02	; 2
 9d2:	a1 1d       	adc	r26, r1
 9d4:	b1 1d       	adc	r27, r1
 9d6:	20 93 71 02 	sts	0x0271, r18	; 0x800271 <timer0_fract>
 9da:	80 93 72 02 	sts	0x0272, r24	; 0x800272 <timer0_millis>
 9de:	90 93 73 02 	sts	0x0273, r25	; 0x800273 <timer0_millis+0x1>
 9e2:	a0 93 74 02 	sts	0x0274, r26	; 0x800274 <timer0_millis+0x2>
 9e6:	b0 93 75 02 	sts	0x0275, r27	; 0x800275 <timer0_millis+0x3>
 9ea:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <timer0_overflow_count>
 9ee:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <timer0_overflow_count+0x1>
 9f2:	a0 91 78 02 	lds	r26, 0x0278	; 0x800278 <timer0_overflow_count+0x2>
 9f6:	b0 91 79 02 	lds	r27, 0x0279	; 0x800279 <timer0_overflow_count+0x3>
 9fa:	01 96       	adiw	r24, 0x01	; 1
 9fc:	a1 1d       	adc	r26, r1
 9fe:	b1 1d       	adc	r27, r1
 a00:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <timer0_overflow_count>
 a04:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <timer0_overflow_count+0x1>
 a08:	a0 93 78 02 	sts	0x0278, r26	; 0x800278 <timer0_overflow_count+0x2>
 a0c:	b0 93 79 02 	sts	0x0279, r27	; 0x800279 <timer0_overflow_count+0x3>
 a10:	bf 91       	pop	r27
 a12:	af 91       	pop	r26
 a14:	9f 91       	pop	r25
 a16:	8f 91       	pop	r24
 a18:	3f 91       	pop	r19
 a1a:	2f 91       	pop	r18
 a1c:	0f 90       	pop	r0
 a1e:	0f be       	out	0x3f, r0	; 63
 a20:	0f 90       	pop	r0
 a22:	1f 90       	pop	r1
 a24:	18 95       	reti

00000a26 <micros>:
 a26:	3f b7       	in	r19, 0x3f	; 63
 a28:	f8 94       	cli
 a2a:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <timer0_overflow_count>
 a2e:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <timer0_overflow_count+0x1>
 a32:	a0 91 78 02 	lds	r26, 0x0278	; 0x800278 <timer0_overflow_count+0x2>
 a36:	b0 91 79 02 	lds	r27, 0x0279	; 0x800279 <timer0_overflow_count+0x3>
 a3a:	26 b5       	in	r18, 0x26	; 38
 a3c:	a8 9b       	sbis	0x15, 0	; 21
 a3e:	05 c0       	rjmp	.+10     	; 0xa4a <micros+0x24>
 a40:	2f 3f       	cpi	r18, 0xFF	; 255
 a42:	19 f0       	breq	.+6      	; 0xa4a <micros+0x24>
 a44:	01 96       	adiw	r24, 0x01	; 1
 a46:	a1 1d       	adc	r26, r1
 a48:	b1 1d       	adc	r27, r1
 a4a:	3f bf       	out	0x3f, r19	; 63
 a4c:	ba 2f       	mov	r27, r26
 a4e:	a9 2f       	mov	r26, r25
 a50:	98 2f       	mov	r25, r24
 a52:	88 27       	eor	r24, r24
 a54:	82 0f       	add	r24, r18
 a56:	91 1d       	adc	r25, r1
 a58:	a1 1d       	adc	r26, r1
 a5a:	b1 1d       	adc	r27, r1
 a5c:	bc 01       	movw	r22, r24
 a5e:	cd 01       	movw	r24, r26
 a60:	42 e0       	ldi	r20, 0x02	; 2
 a62:	66 0f       	add	r22, r22
 a64:	77 1f       	adc	r23, r23
 a66:	88 1f       	adc	r24, r24
 a68:	99 1f       	adc	r25, r25
 a6a:	4a 95       	dec	r20
 a6c:	d1 f7       	brne	.-12     	; 0xa62 <micros+0x3c>
 a6e:	08 95       	ret

00000a70 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 a70:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 a72:	84 b5       	in	r24, 0x24	; 36
 a74:	82 60       	ori	r24, 0x02	; 2
 a76:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 a78:	84 b5       	in	r24, 0x24	; 36
 a7a:	81 60       	ori	r24, 0x01	; 1
 a7c:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 a7e:	85 b5       	in	r24, 0x25	; 37
 a80:	82 60       	ori	r24, 0x02	; 2
 a82:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 a84:	85 b5       	in	r24, 0x25	; 37
 a86:	81 60       	ori	r24, 0x01	; 1
 a88:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 a8a:	ee e6       	ldi	r30, 0x6E	; 110
 a8c:	f0 e0       	ldi	r31, 0x00	; 0
 a8e:	80 81       	ld	r24, Z
 a90:	81 60       	ori	r24, 0x01	; 1
 a92:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 a94:	e1 e8       	ldi	r30, 0x81	; 129
 a96:	f0 e0       	ldi	r31, 0x00	; 0
 a98:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 a9a:	80 81       	ld	r24, Z
 a9c:	82 60       	ori	r24, 0x02	; 2
 a9e:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 aa0:	80 81       	ld	r24, Z
 aa2:	81 60       	ori	r24, 0x01	; 1
 aa4:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 aa6:	e0 e8       	ldi	r30, 0x80	; 128
 aa8:	f0 e0       	ldi	r31, 0x00	; 0
 aaa:	80 81       	ld	r24, Z
 aac:	81 60       	ori	r24, 0x01	; 1
 aae:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 ab0:	e1 eb       	ldi	r30, 0xB1	; 177
 ab2:	f0 e0       	ldi	r31, 0x00	; 0
 ab4:	80 81       	ld	r24, Z
 ab6:	84 60       	ori	r24, 0x04	; 4
 ab8:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 aba:	e0 eb       	ldi	r30, 0xB0	; 176
 abc:	f0 e0       	ldi	r31, 0x00	; 0
 abe:	80 81       	ld	r24, Z
 ac0:	81 60       	ori	r24, 0x01	; 1
 ac2:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 ac4:	ea e7       	ldi	r30, 0x7A	; 122
 ac6:	f0 e0       	ldi	r31, 0x00	; 0
 ac8:	80 81       	ld	r24, Z
 aca:	84 60       	ori	r24, 0x04	; 4
 acc:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
 ace:	80 81       	ld	r24, Z
 ad0:	82 60       	ori	r24, 0x02	; 2
 ad2:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
 ad4:	80 81       	ld	r24, Z
 ad6:	81 60       	ori	r24, 0x01	; 1
 ad8:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 ada:	80 81       	ld	r24, Z
 adc:	80 68       	ori	r24, 0x80	; 128
 ade:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 ae0:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 ae4:	08 95       	ret

00000ae6 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
 ae6:	cf 93       	push	r28
 ae8:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
 aea:	90 e0       	ldi	r25, 0x00	; 0
 aec:	fc 01       	movw	r30, r24
 aee:	e7 52       	subi	r30, 0x27	; 39
 af0:	fe 4f       	sbci	r31, 0xFE	; 254
 af2:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
 af4:	fc 01       	movw	r30, r24
 af6:	e3 51       	subi	r30, 0x13	; 19
 af8:	fe 4f       	sbci	r31, 0xFE	; 254
 afa:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 afc:	88 23       	and	r24, r24
 afe:	61 f1       	breq	.+88     	; 0xb58 <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 b00:	90 e0       	ldi	r25, 0x00	; 0
 b02:	88 0f       	add	r24, r24
 b04:	99 1f       	adc	r25, r25
 b06:	fc 01       	movw	r30, r24
 b08:	e5 5f       	subi	r30, 0xF5	; 245
 b0a:	fd 4f       	sbci	r31, 0xFD	; 253
 b0c:	c5 91       	lpm	r28, Z+
 b0e:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
 b10:	fc 01       	movw	r30, r24
 b12:	ef 5f       	subi	r30, 0xFF	; 255
 b14:	fd 4f       	sbci	r31, 0xFD	; 253
 b16:	a5 91       	lpm	r26, Z+
 b18:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
 b1a:	61 11       	cpse	r22, r1
 b1c:	09 c0       	rjmp	.+18     	; 0xb30 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
 b1e:	9f b7       	in	r25, 0x3f	; 63
                cli();
 b20:	f8 94       	cli
		*reg &= ~bit;
 b22:	88 81       	ld	r24, Y
 b24:	20 95       	com	r18
 b26:	82 23       	and	r24, r18
 b28:	88 83       	st	Y, r24
		*out &= ~bit;
 b2a:	ec 91       	ld	r30, X
 b2c:	2e 23       	and	r18, r30
 b2e:	0b c0       	rjmp	.+22     	; 0xb46 <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
 b30:	62 30       	cpi	r22, 0x02	; 2
 b32:	61 f4       	brne	.+24     	; 0xb4c <pinMode+0x66>
		uint8_t oldSREG = SREG;
 b34:	9f b7       	in	r25, 0x3f	; 63
                cli();
 b36:	f8 94       	cli
		*reg &= ~bit;
 b38:	88 81       	ld	r24, Y
 b3a:	32 2f       	mov	r19, r18
 b3c:	30 95       	com	r19
 b3e:	83 23       	and	r24, r19
 b40:	88 83       	st	Y, r24
		*out |= bit;
 b42:	ec 91       	ld	r30, X
 b44:	2e 2b       	or	r18, r30
 b46:	2c 93       	st	X, r18
		SREG = oldSREG;
 b48:	9f bf       	out	0x3f, r25	; 63
 b4a:	06 c0       	rjmp	.+12     	; 0xb58 <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
 b4c:	8f b7       	in	r24, 0x3f	; 63
                cli();
 b4e:	f8 94       	cli
		*reg |= bit;
 b50:	e8 81       	ld	r30, Y
 b52:	2e 2b       	or	r18, r30
 b54:	28 83       	st	Y, r18
		SREG = oldSREG;
 b56:	8f bf       	out	0x3f, r24	; 63
	}
}
 b58:	df 91       	pop	r29
 b5a:	cf 91       	pop	r28
 b5c:	08 95       	ret

00000b5e <__udivmodqi4>:
 b5e:	99 1b       	sub	r25, r25
 b60:	79 e0       	ldi	r23, 0x09	; 9
 b62:	04 c0       	rjmp	.+8      	; 0xb6c <__udivmodqi4_ep>

00000b64 <__udivmodqi4_loop>:
 b64:	99 1f       	adc	r25, r25
 b66:	96 17       	cp	r25, r22
 b68:	08 f0       	brcs	.+2      	; 0xb6c <__udivmodqi4_ep>
 b6a:	96 1b       	sub	r25, r22

00000b6c <__udivmodqi4_ep>:
 b6c:	88 1f       	adc	r24, r24
 b6e:	7a 95       	dec	r23
 b70:	c9 f7       	brne	.-14     	; 0xb64 <__udivmodqi4_loop>
 b72:	80 95       	com	r24
 b74:	08 95       	ret

00000b76 <__tablejump2__>:
 b76:	ee 0f       	add	r30, r30
 b78:	ff 1f       	adc	r31, r31
 b7a:	05 90       	lpm	r0, Z+
 b7c:	f4 91       	lpm	r31, Z
 b7e:	e0 2d       	mov	r30, r0
 b80:	09 94       	ijmp

00000b82 <memcpy_P>:
 b82:	fb 01       	movw	r30, r22
 b84:	dc 01       	movw	r26, r24
 b86:	02 c0       	rjmp	.+4      	; 0xb8c <memcpy_P+0xa>
 b88:	05 90       	lpm	r0, Z+
 b8a:	0d 92       	st	X+, r0
 b8c:	41 50       	subi	r20, 0x01	; 1
 b8e:	50 40       	sbci	r21, 0x00	; 0
 b90:	d8 f7       	brcc	.-10     	; 0xb88 <memcpy_P+0x6>
 b92:	08 95       	ret

00000b94 <__do_global_dtors>:
 b94:	11 e0       	ldi	r17, 0x01	; 1
 b96:	cc e0       	ldi	r28, 0x0C	; 12
 b98:	d1 e0       	ldi	r29, 0x01	; 1
 b9a:	04 c0       	rjmp	.+8      	; 0xba4 <__do_global_dtors+0x10>
 b9c:	fe 01       	movw	r30, r28
 b9e:	0e 94 bb 05 	call	0xb76	; 0xb76 <__tablejump2__>
 ba2:	21 96       	adiw	r28, 0x01	; 1
 ba4:	cd 30       	cpi	r28, 0x0D	; 13
 ba6:	d1 07       	cpc	r29, r17
 ba8:	c9 f7       	brne	.-14     	; 0xb9c <__do_global_dtors+0x8>
 baa:	f8 94       	cli

00000bac <__stop_program>:
 bac:	ff cf       	rjmp	.-2      	; 0xbac <__stop_program>
